syntax = "proto3";

package underworlds;

service Underworlds {

    // Establish the connection to the server, setting a human-friendly name for
    // the client.
    // The server returns a unique client ID that must be used in every subsequent
    // request to the server.
    rpc helo(Name) returns (Client) {}

    // Returns the uptime of the server, in seconds
    rpc uptime(Client) returns (Time) {}

    // Returns the current topology of underworlds: the list of worlds and the
    // list of clients + their interactions with the worlds
    rpc topology(Client) returns (Topology) {}

    // NODES

    // Returns the number of nodes in a given world.
    // 
    // Accepts a context (client ID and world) and returns the number of existing nodes.
    rpc getNodesLen(Context) returns (Size) {}

    // Returns the list of node IDs present in the given world
    rpc getNodesIds(Context) returns (Nodes) {}

    // Returns the root node ID of the given world
    rpc getRootNode(Context) returns (Node) {}

    // Returns a node from its ID in the given world.
    // Note that only the node ID is used (and thus, required).
    rpc getNode(NodeInContext) returns (Node) {}

    // Updates (and broadcasts to all client) a node in a given world
    rpc updateNode(NodeInContext) returns (Empty) {}

    // Deletes (and broadcasts to all client) a node in a given world
    rpc deleteNode(NodeInContext) returns (Empty) {}

    // Returns a (stream of) 'invalidated' nodes that need to be updated.
    // Invalidated nodes can be new nodes, nodes that have changed, or nodes
    // that have been removed (see Invalidation.type).
    rpc getNodeInvalidations(Context) returns (stream NodeInvalidation) {}


    // TIMELINE

    rpc timelineOrigin(Context) returns (Time) {}

    // Returns a (stream of) 'invalidated' nodes that need to be updated.
    // Invalidated nodes can be new nodes, nodes that have changed, or nodes
    // that have been removed (see Invalidation.type).
    rpc getTimelineInvalidations(Context) returns (stream TimelineInvalidation) {}


}

enum NodeType {
    UNDEFINED = 0;
    // Entities are abstract nodes. They can represent non-physical objects
    // (like a reference frame) or groups of other objects.
    ENTITY = 1; 
    // a physical object, with an associated 3D mesh
    MESH = 2;
    CAMERA = 3;
}

enum NodeInvalidationType {
    NEW = 0;
    UPDATE = 1;
    DELETE = 2;
}

enum TimelineInvalidationType {
    EVENT = 0;
    START = 1;
    END = 2;
}

enum InteractionType {
    READER = 0;
    PROVIDER = 1;
    MONITOR = 2;
    FILTER = 3;
}
    
message Client {
    string id = 1;
    string name = 2;
    repeated ClientInteraction links = 3;
}

message ClientInteraction {
    string world = 1;
    InteractionType type = 2;
    Time last_activity = 3;
}

message Context {
    string client = 1;
    string world = 2;
}

message Name {
    string name = 1;
}

message Size {
    int32 size = 1;
}

// Encodes the current topology of Underworlds
message Topology {
    repeated string worlds = 1;
    repeated Client clients = 2;
}

message Node {
    // an unique ID
    string id = 1;

    // a human-friendly name
    string name = 2;

    // the type of node
    NodeType type = 3;

    string parent = 4; // the parent node ID. Always non-empty, except for the root node

    // the children of this node, if any
    repeated string children = 5;

    // 4x4 transformation matrix, relative to parent. Translation units are
    // meters. Stored as a list of 16 double, row-major.
    repeated double transformation = 6;

    // date/time of the last node's update (in sec since the epoch)
    double last_update = 8;

    // PROPERTIES

    // if set to true, physics-related computation are expected to be run on this node
    bool physics = 16;
}

message Nodes {
    repeated string ids = 1;
}

message NodeInContext {
    Context context = 1;
    Node node = 2;
}

message NodeInvalidation {
    NodeInvalidationType type = 1;

    // the ID of the node which is being invalidated
    string id = 2;
}

message Time {
    // Time (in second). Can represent an absolute time (seconds elapsed since
    // the begining of epoch) or a duration.
    double time = 1;
}

message TimelineInvalidation {
    TimelineInvalidationType type = 1;

    // the ID of the situation which is being invalidated
    string id = 2;
}

message Empty {}
