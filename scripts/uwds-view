#!/usr/bin/env python
#-*- coding: UTF-8 -*-

""" This program loads a underworlds world, and display its
3D scene.

Based on:
- pygame + mouselook code from http://3dengine.org/Spectator_%28PyOpenGL%29
 - http://www.lighthouse3d.com/tutorials
 - http://www.songho.ca/opengl/gl_transform.html
 - http://code.activestate.com/recipes/325391/
 - ASSIMP's C++ SimpleOpenGL viewer
"""
import sys

import logging
logger = logging.getLogger("underworlds.3d_viewer")
gllogger = logging.getLogger("OpenGL")
gllogger.setLevel(logging.WARNING)
logging.basicConfig(level=logging.INFO)

import OpenGL
#OpenGL.ERROR_CHECKING=False
#OpenGL.ERROR_LOGGING = False
#OpenGL.ERROR_ON_COPY = True
#OpenGL.FULL_LOGGING = True
from OpenGL.GL import *
from OpenGL.error import GLError
from OpenGL.GLU import *
from OpenGL.GLUT import *
from OpenGL.arrays import vbo
from OpenGL.GL import shaders

import pygame
import pygame.font
import pygame.image

import math, random
import numpy
from numpy import linalg


import underworlds
from underworlds.types import *


#rendering mode
BASE = "BASE"
COLORS = "COLORS"

def transform(vector3, matrix4x4):
    """ Apply a transformation matrix on a 3D vector.

    :param vector3: a numpy array with 3 elements
    :param matrix4x4: a numpy 4x4 matrix
    """
    return numpy.dot(matrix4x4, numpy.append(vector3, 1.))

def get_bounding_box(scene):
    nodes = scene.nodes
    bb_min = [1e10, 1e10, 1e10] # x,y,z
    bb_max = [-1e10, -1e10, -1e10] # x,y,z

    return get_bounding_box_for_node(nodes, scene.rootnode, bb_min, bb_max, linalg.inv(scene.rootnode.transformation))

def get_bounding_box_for_node(nodes, node, bb_min, bb_max, transformation):

    transformation = numpy.dot(transformation, node.transformation)
    if node.type == MESH:
        for v in node.aabb:
            v = transform(v, transformation)
            bb_min[0] = min(bb_min[0], v[0])
            bb_min[1] = min(bb_min[1], v[1])
            bb_min[2] = min(bb_min[2], v[2])
            bb_max[0] = max(bb_max[0], v[0])
            bb_max[1] = max(bb_max[1], v[1])
            bb_max[2] = max(bb_max[2], v[2])

    for child in node.children:
        bb_min, bb_max = get_bounding_box_for_node(nodes, nodes[child], bb_min, bb_max, transformation)

    return bb_min, bb_max

class DefaultCamera:
    def __init__(self, w, h, fov):
        self.clipplanenear = 0.001
        self.clipplanefar = 100000.0
        self.aspect = w/h
        self.horizontalfov = fov * math.pi/180
        self.transformation = [[ 0.68, -0.32, 0.65, 7.48],
                               [ 0.73,  0.31, -0.61, -6.51],
                               [-0.01,  0.89,  0.44,  5.34],
                               [ 0.,    0.,    0.,    1.  ]]
        self.lookat = [0.0,0.0,-1.0]

    def __str__(self):
        return "Default camera"


class Underworlds3DViewer:

    base_name = "Underworlds 3D viewer"

    def __init__(self, ctx, world, w=1024, h=768, fov=75):

        self.w = w
        self.h = h

        pygame.init()
        self.base_name = self.base_name + " <%s>" % world
        pygame.display.set_caption(self.base_name)
        pygame.display.set_mode((w,h), pygame.OPENGL | pygame.DOUBLEBUF)

        self.prepare_shaders()

        self.fontmanager = FontManager(None, w, h, 18)

        self.ctx = ctx
        self.world = ctx.worlds[world]

        self.scene = None
        self.meshes = {} # stores the OpenGL vertex/faces/normals buffers pointers

        self.node2colorid = {} # stores a color ID for each node. Useful for mouse picking and visibility checking
        self.colorid2node = {} # reverse dict of node2colorid

        self.currently_selected = None

        self.cameras = [DefaultCamera(w,h,fov)]
        self.current_cam_index = 0

        self.load_world()

        # for FPS computation
        self.frames = 0
        self.last_fps_time = glutGet(GLUT_ELAPSED_TIME)


        self.cycle_cameras()

    def prepare_shaders(self):

        phong_weightCalc = """
        float phong_weightCalc(
            in vec3 light_pos, // light position
            in vec3 frag_normal // geometry normal
        ) {
            // returns vec2( ambientMult, diffuseMult )
            float n_dot_pos = max( 0.0, dot(
                frag_normal, light_pos
            ));
            return n_dot_pos;
        }
        """

        flatvertex = shaders.compileShader(
        """
        uniform vec4 Material_diffuse;
        attribute vec3 Vertex_position;
        varying vec4 baseColor;
        void main() {
            gl_Position = gl_ModelViewProjectionMatrix * vec4(
                Vertex_position, 1.0
            );
            baseColor = Material_diffuse;
        }""", GL_VERTEX_SHADER)

        vertex = shaders.compileShader( phong_weightCalc +
        """
        uniform vec4 Global_ambient;
        uniform vec4 Light_ambient;
        uniform vec4 Light_diffuse;
        uniform vec3 Light_location;
        uniform vec4 Material_ambient;
        uniform vec4 Material_diffuse;
        attribute vec3 Vertex_position;
        attribute vec3 Vertex_normal;
        varying vec4 baseColor;
        void main() {
            gl_Position = gl_ModelViewProjectionMatrix * vec4(
                Vertex_position, 1.0
            );
            vec3 EC_Light_location = gl_NormalMatrix * Light_location;
            float diffuse_weight = phong_weightCalc(
                normalize(EC_Light_location),
                normalize(gl_NormalMatrix * Vertex_normal)
            );
            baseColor = clamp(
            (
                // global component
                (Global_ambient * Material_ambient)
                // material's interaction with light's contribution
                // to the ambient lighting...
                + (Light_ambient * Material_ambient)
                // material's interaction with the direct light from
                // the light.
                + (Light_diffuse * Material_diffuse * diffuse_weight)
            ), 0.0, 1.0);
        }""", GL_VERTEX_SHADER)

        fragment = shaders.compileShader("""
        varying vec4 baseColor;
        void main() {
            gl_FragColor = baseColor;
        }
        """, GL_FRAGMENT_SHADER)

        self.flatshader = shaders.compileProgram(flatvertex,fragment)
        self.set_shader_accessors( ('Material_diffuse',), ('Vertex_position',), self.flatshader)

        self.shader = shaders.compileProgram(vertex,fragment)
        self.set_shader_accessors( (
            'Global_ambient',
            'Light_ambient','Light_diffuse','Light_location',
            'Material_ambient','Material_diffuse',
        ), (
            'Vertex_position','Vertex_normal',
        ), self.shader)

    def set_shader_accessors(self, uniforms, attributes, shader):
        # add accessors to the shaders uniforms and attributes
        for uniform in uniforms:
            location = glGetUniformLocation( shader,  uniform )
            if location in (None,-1):
                logger.warning('No uniform: %s'%( uniform ))
            setattr( shader, uniform, location )

        for attribute in attributes:
            location = glGetAttribLocation( shader, attribute )
            if location in (None,-1):
                logger.warning('No attribute: %s'%( attribute ))
            setattr( shader, attribute, location )

    def prepare_gl_buffers(self, id):

        meshes = self.meshes

        if id in meshes:
            # mesh already loaded. Fine
            return

        meshes[id] = {}

        # leave some time for new nodes to push their meshes
        while not self.ctx.has_mesh(id):
            time.sleep(0.01)

        mesh = self.ctx.mesh(id) # retrieve the mesh from the server

        # Fill the buffer for vertex and normals positions
        v = numpy.array(mesh["vertices"], 'f')
        n = numpy.array(mesh["normals"], 'f')

        #meshes[id]["vbo"] = glGenBuffers(1)
        #glBindBuffer(GL_ARRAY_BUFFER, meshes[id]["vbo"])
        #glBufferData(GL_ARRAY_BUFFER, 
        #            numpy.hstack((v,n)), # concatenate vertices and normals in one array
        #            GL_STATIC_DRAW)

        meshes[id]["vbo"] = vbo.VBO(numpy.hstack((v,n)))

        # Fill the buffer for vertex positions
        meshes[id]["faces"] = glGenBuffers(1)
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, meshes[id]["faces"])
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, 
                    numpy.array(mesh["faces"], dtype=numpy.int32),
                    GL_STATIC_DRAW)

        meshes[id]["nbfaces"] = len(mesh["faces"])
        meshes[id]["material"] = mesh["material"]

        # Unbind buffers
        glBindBuffer(GL_ARRAY_BUFFER,0)
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,0)

    def get_rgb_from_colorid(self, colorid):
        r = (colorid >> 0) & 0xff
        g = (colorid >> 8) & 0xff
        b = (colorid >> 16) & 0xff

        return (r,g,b)

    def get_color_id(self):
        id = random.randint(0, 256*256*256)
        if id not in self.colorid2node:
            return id
        else:
            return self.get_color_id()

    def glize(self, node):

        logger.info("Loading node <%s>" % node)

        node.selected = False
        node.transformation = numpy.array(node.transformation)

        if node.type == MESH:
            colorid = self.get_color_id()
            self.colorid2node[colorid] = node
            self.node2colorid[node] = colorid

            if hasattr(node, "cad"):
                node.glmeshes = node.cad
            elif hasattr(node, "lowres"):
                node.glmeshes = node.lowres
            elif hasattr(node, "hires"):
                node.glmeshes = node.hires
            else:
                raise StandardError("The node %s has no mesh available!" % node.name)
            for mesh in node.glmeshes:
                self.prepare_gl_buffers(mesh)

        elif node.type == CAMERA:
            logger.info("Added camera <%s>" % node.name)
            self.cameras.append(node)


    def load_world(self):
        logger.info("Preparing world <%s> for 3D rendering..." % self.world)

        scene = self.scene = self.world.scene
        nodes = scene.nodes
        for node in nodes:
            self.glize(node)

        #log some statistics
        logger.info("  -> %d nodes" % len(nodes))
        self.bb_min, self.bb_max = get_bounding_box(scene)
        logger.info("  -> scene bounding box:" + str(self.bb_min) + " - " + str(self.bb_max))

        self.scene_center = [(a + b) / 2. for a, b in zip(self.bb_min, self.bb_max)]

        logger.info("World <%s> ready for 3D rendering." % self.world)

    def cycle_cameras(self):
        if not self.cameras:
            logger.info("No camera in the scene")
            return None
        self.current_cam_index = (self.current_cam_index + 1) % len(self.cameras)
        self.current_cam = self.cameras[self.current_cam_index]
        self.set_camera(self.current_cam)
        logger.info("Switched to camera <%s>" % self.current_cam)

    def set_overlay_projection(self):
        glViewport(0,0,self.w,self.h)
        glMatrixMode(GL_PROJECTION)
        glLoadIdentity()
        glOrtho(0.0, self.w - 1.0, 0.0, self.h - 1.0, -1.0, 1.0)
        glMatrixMode(GL_MODELVIEW)
        glLoadIdentity()

    def set_camera_projection(self, camera = None):

        if not camera:
            camera = self.cameras[self.current_cam_index]

        znear = camera.clipplanenear
        zfar = camera.clipplanefar
        aspect = camera.aspect
        fov = camera.horizontalfov

        glMatrixMode(GL_PROJECTION)
        glLoadIdentity()

        # Compute gl frustrum
        tangent = math.tan(fov/2.)
        h = znear * tangent
        w = h * aspect

        # params: left, right, bottom, top, near, far
        glFrustum(-w, w, -h, h, znear, zfar)
        # equivalent to:
        #gluPerspective(fov * 180/math.pi, aspect, znear, zfar)
        glMatrixMode(GL_MODELVIEW)
        glLoadIdentity()


    def set_camera(self, camera):

        self.set_camera_projection(camera)

        glMatrixMode(GL_MODELVIEW)
        glLoadIdentity()

        cam = transform([0.0, 0.0, 0.0], camera.transformation)
        at = transform(camera.lookat, camera.transformation)
        gluLookAt(cam[0], cam[2], -cam[1],
                   at[0],  at[2],  -at[1],
                       0,      1,       0)

    def render_colors(self):

        glEnable(GL_DEPTH_TEST)
        glDepthFunc(GL_LEQUAL)


        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)
        glEnable(GL_CULL_FACE)

        glUseProgram(self.flatshader)

        self.recursive_render(self.scene.rootnode, self.flatshader, mode=COLORS)

        glUseProgram( 0 )

    def get_hovered_node(self, mousex, mousey):
        """
        Attention: The performances of this method relies heavily on the size of the display!
        """

        self.render_colors()
        # Capture image from the OpenGL buffer
        buf = ( GLubyte * (3 * self.w * self.h) )(0)
        glReadPixels(0, 0, self.w, self.h, GL_RGB, GL_UNSIGNED_BYTE, buf)

        #Reinterpret the RGB pixel buffer as a 1-D array of 24bits colors
        a = numpy.ndarray(len(buf), numpy.dtype('>u1'), buf)
        colors = numpy.zeros(len(buf) / 3, numpy.dtype('<u4'))
        for i in range(3):
            colors.view(dtype='>u1')[i::4] = a.view(dtype='>u1')[i::3]

        colorid = colors[mousex + mousey * self.w]

        if colorid:
            try:
                return self.colorid2node[colorid]
            except KeyError:
                logger.warning("Unknown colorID %d" % colorid)

        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)

    def check_visibility(self):
        """
        Attention: The performances of this method relies heavily on the size of the display!
        """
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
        self.render_colors()
        # Capture image from the OpenGL buffer
        buf = ( GLubyte * (3 * self.w * self.h) )(0)
        glReadPixels(0, 0, self.w, self.h, GL_RGB, GL_UNSIGNED_BYTE, buf)

        #Reinterpret the RGB pixel buffer as a 1-D array of 24bits colors
        a = numpy.ndarray(len(buf), numpy.dtype('>u1'), buf)
        colors = numpy.zeros(len(buf) / 3, numpy.dtype('<u4'))
        for i in range(3):
            colors.view(dtype='>u1')[i::4] = a.view(dtype='>u1')[i::3]

        colors = colors[numpy.nonzero(colors)] #discard black background
        
        if colors.any():
            bins = numpy.bincount(colors)
            ii = numpy.nonzero(bins)[0]

            for i in ii:
                print ("Node %s is visible (%d pix)" % (self.colorid2node[i], bins[i]))
        else:
            print("Nothing visible!")

        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)

    def screenshot(self, filename = "screenshot.png"):

        logger.info("Taking a screenshot...")
        import Image
        # Capture image from the OpenGL buffer
        buffer = ( GLubyte * (3 * self.w * self.h) )(0)
        glReadPixels(0, 0, self.w, self.h, GL_RGB, GL_UNSIGNED_BYTE, buffer)

        # Use PIL to convert raw RGB buffer and flip the right way up
        image = Image.fromstring(mode="RGB", size=(self.w, self.h), data=buffer)
        image = image.transpose(Image.FLIP_TOP_BOTTOM)

        # Save image to disk
        image.save(filename)
        logger.info("...done. Image saved as <%s>." % filename)


    def render(self, wireframe = False, twosided = False):

        glEnable(GL_DEPTH_TEST)
        glDepthFunc(GL_LEQUAL)


        glPolygonMode(GL_FRONT_AND_BACK, GL_LINE if wireframe else GL_FILL)
        glDisable(GL_CULL_FACE) if twosided else glEnable(GL_CULL_FACE)

        shader = self.shader

        glUseProgram(shader)
        glUniform4f( shader.Global_ambient, .4,.2,.2,.1 )
        glUniform4f( shader.Light_ambient, .4,.4,.4, 1.0 )
        glUniform4f( shader.Light_diffuse, 1,1,1,1 )
        glUniform3f( shader.Light_location, 2,2,10 )

        self.recursive_render(self.scene.rootnode, shader)


        glUseProgram( 0 )

    def recursive_render(self, node, shader, mode = BASE):
        """ Main recursive rendering method.
        """

        normals = True
        ambient = True
        if mode == COLORS:
            normals = False
            ambient = False

        # save model matrix and apply node transformation
        glPushMatrix()
        try:
            m = node.transformation.transpose() # OpenGL row major
        except AttributeError:
            #probably a new incoming node, that has not yet been converted to numpy
            self.glize(node)
            m = node.transformation.transpose() # OpenGL row major
        glMultMatrixf(m)

        if node.type == MESH:


            for id in node.glmeshes:

                stride = 24 # 6 * 4 bytes

                if node.selected:
                    glUniform4f( shader.Material_diffuse, 1.0, 0.0, 0.0, 1.0 )
                else:
                    if mode == COLORS:
                            colorid = self.node2colorid[node]
                            r,g,b= self.get_rgb_from_colorid(colorid)
                            glUniform4f( shader.Material_diffuse, r/255.0,g/255.0,b/255.0,1.0 )
                    else:
                        mat = self.meshes[id]["material"]
                        glUniform4f( shader.Material_diffuse, *mat["diffuse"] )
                        if ambient:
                            glUniform4f( shader.Material_ambient, *mat["ambient"] )


                vbo = self.meshes[id]["vbo"]
                vbo.bind()

                glEnableVertexAttribArray( shader.Vertex_position )
                if normals:
                    glEnableVertexAttribArray( shader.Vertex_normal )

                glVertexAttribPointer(
                    shader.Vertex_position,
                    3, GL_FLOAT,False, stride, vbo
                )

                if normals:
                    glVertexAttribPointer(
                        shader.Vertex_normal,
                        3, GL_FLOAT,False, stride, vbo+12
                    )

                glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self.meshes[id]["faces"])
                glDrawElements(GL_TRIANGLES, self.meshes[id]["nbfaces"] * 3, GL_UNSIGNED_INT, None)


                vbo.unbind()
                glDisableVertexAttribArray( shader.Vertex_position )

                if normals:
                    glDisableVertexAttribArray( shader.Vertex_normal )


                glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0)

        for child in node.children:
            self.recursive_render(self.scene.nodes[child], shader, mode)

        glPopMatrix()

    def switch_to_overlay(self):
        glPushMatrix()
        self.set_overlay_projection()

    def switch_from_overlay(self):
        self.set_camera_projection()
        glPopMatrix()


    def display(self, text, x, y):
        self.fontmanager.display(text,x,y)

    def select_node(self, node):
        self.currently_selected = node
        for n in self.scene.nodes:
            if n is node:
                n.selected = True
            else:
                n.selected = False

    def loop(self):

        pygame.display.flip()
        event = pygame.event.poll()
        self.keys = [k for k, pressed in enumerate(pygame.key.get_pressed()) if pressed]

        if event.type == pygame.KEYDOWN:
            if pygame.K_f in self.keys: pygame.display.toggle_fullscreen()
            if pygame.K_s in self.keys: self.screenshot()
            if pygame.K_v in self.keys: self.check_visibility()
            if pygame.K_TAB in self.keys: self.cycle_cameras()
            if pygame.K_ESCAPE in self.keys:
                return False

        if event.type == pygame.MOUSEBUTTONDOWN:

            if pygame.mouse.get_pressed()[0]: # left button pressed
                mousex, mousey = pygame.mouse.get_pos()
                hovered = self.get_hovered_node(mousex, self.h - mousey)
                if hovered:
                    logger.debug("Node %s selected" % hovered)
                    self.select_node(hovered)
                else:
                    self.select_node(None)
            if pygame.mouse.get_pressed()[2]: # right button pressed
                self.select_node(None)

        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)

        # Compute FPS
        gl_time = glutGet(GLUT_ELAPSED_TIME)
        self.frames += 1
        if gl_time - self.last_fps_time >= 1000:
            current_fps = self.frames * 1000 / (gl_time - self.last_fps_time)
            pygame.display.set_caption(self.base_name + " - %.0f fps" % current_fps)
            self.frames = 0
            self.last_fps_time = gl_time


        return True

    def controls_3d(self,
                    mouse_button=1, \
                    up_key=pygame.K_UP, \
                    down_key=pygame.K_DOWN, \
                    left_key=pygame.K_LEFT, \
                    right_key=pygame.K_RIGHT):
        """ The actual camera setting cycle """
        mouse_dx,mouse_dy = pygame.mouse.get_rel()
        if pygame.mouse.get_pressed()[mouse_button]:
            look_speed = .2
            buffer = glGetDoublev(GL_MODELVIEW_MATRIX)
            c = (-1 * numpy.mat(buffer[:3,:3]) * \
                numpy.mat(buffer[3,:3]).T).reshape(3,1)
            # c is camera center in absolute coordinates, 
            # we need to move it back to (0,0,0) 
            # before rotating the camera
            glTranslate(c[0],c[1],c[2])
            m = buffer.flatten()
            glRotate(mouse_dx * look_speed, m[1],m[5],m[9])
            glRotate(mouse_dy * look_speed, m[0],m[4],m[8])
            
            # compensate roll
            glRotated(-math.atan2(-m[4],m[5]) * \
                57.295779513082320876798154814105 ,m[2],m[6],m[10])
            glTranslate(-c[0],-c[1],-c[2])

        # move forward-back or right-left
        if up_key in self.keys:
            fwd = .1
        elif down_key in self.keys:
            fwd = -.1
        else:
            fwd = 0

        if left_key in self.keys:
            strafe = .1
        elif right_key in self.keys:
            strafe = -.1
        else:
            strafe = 0

        if abs(fwd) or abs(strafe):
            if not self.currently_selected:
                m = glGetDoublev(GL_MODELVIEW_MATRIX).flatten()
                glTranslate(fwd*m[2],fwd*m[6],fwd*m[10])
                glTranslate(strafe*m[0],strafe*m[4],strafe*m[8])
            else:
                self.move_selected_node(fwd, strafe)

    def move_selected_node(self, fwd, strafe):
        self.currently_selected.transformation[0][3] += strafe
        self.currently_selected.transformation[2][3] += fwd
        t = self.currently_selected.transformation
        self.currently_selected.transformation = self.currently_selected.transformation.tolist()
        self.scene.nodes.update(self.currently_selected)
        self.currently_selected.transformation = t

def main():
    with underworlds.Context("3D viewer") as ctx:
        app = Underworlds3DViewer(ctx, world = sys.argv[1])

        while app.loop():
            app.render()
            app.switch_to_overlay()
            app.display("world <%s>"% app.world, 10,10)
            if app.currently_selected: app.display("node <%s>"% app.currently_selected, 10,30)
            app.switch_from_overlay()
            app.controls_3d(0)


#########################################################################
#                               FONT MANAGEMENT                         #
#########################################################################
"""
    Copyright (c) 2002. Nelson Rush. All rights reserved.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
"""

class FontManager:
    def __init__(self, fontname, width, height, fontsize = 18):

        self.w = width
        self.h = height
        pygame.font.init()
        if not pygame.font.get_init():
            print 'Could not render font.'
            raise Exception("Error while initializing the font rendering engine")

        self.font = pygame.font.Font(fontname, fontsize)
        self.char = []
        for c in range(256):
            self.char.append(self.CreateCharacter(chr(c)))
        self.char = tuple(self.char)
        self.lw = self.char[ord('0')][1]
        self.lh = self.char[ord('0')][2]

    def CreateCharacter(self, s):
        try:
            letter_render = self.font.render(s, 1, (255,255,255), (0,0,0))
            letter = pygame.image.tostring(letter_render, 'RGBA', 1)
            letter_w, letter_h = letter_render.get_size()
        except:
            letter = None
            letter_w = 0
            letter_h = 0
        return (letter, letter_w, letter_h)

    def display(self, text, x, y):
        s = str(text)
        i = 0
        lx = 0
        length = len(s)
        glPushMatrix()
        while i < length:
            glRasterPos2i(x + lx, y)
            ch = self.char[ ord( s[i] ) ]
            glDrawPixels(ch[1], ch[2], GL_RGBA, GL_UNSIGNED_BYTE, ch[0])
            lx += ch[1]
            i += 1
        glPopMatrix()

    def __del__(self):
        pygame.font.quit()
if __name__ == '__main__':
    if not len(sys.argv) > 1:
        print("Usage: " + __file__ + " <world name>")
        sys.exit(2)

    main()


